// module main;
import { describe, isJust, isNone, InternalError, is_kind, is_kind_tag} from '../src/sjs-parser.mjs';


let emitter;

// { writer, current_indent, indent_stack, current_line, current_column }


let lang;

// { fn, do,end }


fn to_s(value) do
  return describe(value, 2000);
end

fn indent(extra_indent) do
  emitter.indent_stack.push(emitter.current_indent);
  emitter.current_indent += extra_indent;
end

fn undent() do
  emitter.current_indent = emitter.indent_stack.pop();
end

fn emit(text) do
  // process.stdout.write(text);  // for echoing to stdout as it's generated
  
  emitter.writer(text);
  let i = 0;
  while i < text.length do
    if text[i] === '\n' then
      emitter.current_line++;
      emitter.current_column = 1;
    else
      emitter.current_column++;
    end
    i++;
  end
  //var image = 'emitting: ';
  //for (let i = 1; i < emitter.current_column; i++) image += '.';
  //image += text;
  //image = image.replace(/\n/g, '\nemitting: ');
  //if (image[image.length-1] != '\n') image += '\n';
  //console.log(image);
  // console.log(`line: ${emitter.current_line}, column: ${emitter.current_column}`);
  
end

fn nl_no_indent() do
  emitter.writer('\n');
  emitter.current_line++;
  emitter.current_column = 1;
end

fn nl_and_indent() do
  emit('\n' + emitter.current_indent);
end

fn nl_emit(text) do
  emit('\n' + emitter.current_indent + text);
end

fn maybe_nl_emit(should_newline, text) do
  if should_newline then
    nl_emit(text);
  else
    emit(text);
  end
end

fn is_sp_keyword(text) do
  return /^(as|async|await|const|do|else|elsif|end|export|if|fn|for|from|import|let|module|new|of|return|then|throw|typeof|var|while)$/.test(text);
end

fn is_js_keyword(text) do
  return /^(as|async|await|const|else|export|if|for|from|import|let|module|new|of|return|then|throw|typeof|var|while)$/.test(text);
end

export fn Generate(output_language, input_file_name, unit, writer) do
  emitter = {
    output_language,
    writer,
    current_indent: '',
    indent_stack: [ ],
    current_line: 1,
    current_column: 1
  };
  lang = {
    func: output_language === 'js' ? 'function' : 'fn',
    begin_block: output_language === 'js' ? '{' : 'do',
    end_block: output_language === 'js' ? '}' : 'end',
    emit_if_stmt: output_language === 'js' ? js_emit_statement_if : sp1_emit_statement_if,
    test_lpar: output_language === 'js' ? '(' : '',
    test_rpar: output_language === 'js' ? ')' : '',
    is_keyword: output_language === 'js' ? is_js_keyword : is_sp_keyword
  };
  emit_unit(unit);
end

fn die(message) do
  throw new InternalError(message);
end

fn nyi(message) do
  die(`Not yet implemented: ${message}`);
end

fn emit_unit(unit) do
  // unit is               { Kind: 'Unit', Tag: 'Unit', ModuleComments, Module, ImportList, DeclarationList, ExpectedOutput };
  // ModuleComments is     { Kind: 'Declaration', Tag: 'Comments', Comments: [token...] }
  // Module is             Maybe(ModuleName)
  // ModuleName is         { Kind: 'ModuleName', Tag: 'ModuleName', Module: token, Name: token }
  // ImportList is         [ Import... ]
  // DeclarationList is    [ Declaration... ]
  
  emit_declaration_comments(unit.ModuleComments);
  let name = isJust(unit.Module) ? unit.Module.Just.Name : 'main';
  emit(`// module ${name};`);
  for let item of unit.ImportList do
    nl_and_indent();
    emit_import(item);
  end
  nl_and_indent();
  for let decl of unit.DeclarationList do
    nl_no_indent();
    nl_and_indent();
    emit_declaration(decl);
  end
  emit('\n');
  emit(unit.ExpectedOutput);
end

fn emit_import(item) do
  // item       is  { Kind: 'Import', Tag: 'Import', Import, Lbrace, Rbrace, From, ModulePath, ImportList}
  //            or  { Kind: 'Import', Tag: 'As', Import, Star, As, From, Name, ModulePath }
  // Import     is  Token
  // Star       is  Token
  // As         is  Token
  // From       is  Token
  // Name       is  Token/SYMBOL
  // ModulePath is  Token/STRING
  // ImportList is  { Kind: 'List', Tag: 'Identifiers', Identifiers: [token...], Commas: [token...] }
  
  if item.Tag === 'Import' then
    let start_line = emitter.current_line;
    emit(`import { `);
    indent('       ');
    let comma = '';
    let newlines = false;
    let names = item.ImportList.Identifiers.map((tok) => tok.Text);
    for let name of names do
      let out = comma + name;
      comma = ", ";
      let too_long = emitter.current_column + out.length > 72;
      maybe_nl_emit(too_long, out);
      newlines = newlines || too_long;
    end
    maybe_nl_emit(newlines, `} from ${item.ModulePath.Text};`);
    undent();
  elsif item.Tag === 'As' then
    emit(`import * as ${item.Name.Text} from ${item.ModulePath.Text};`);
  end
end

fn emit_declaration(decl) do
  // decl is            Declaration
  // Declaration has    { Kind: 'Declaration', Tag: 'Comments', Comments: [token...] }
  //              or    { Kind: 'Declaration', Tag: 'Function', Name, Signature, Body, Exported, IsAsync }
  //              or    { Kind: 'Declaration', Tag: 'Variable', Keyword, Variable, Initializer, Exported };
  //              or    { Kind: 'Declaration', Tag: 'Variables', Keyword, Variables, Initializer, Exported };
  //              or    { Kind: 'Declaration', Tag: 'Statement', Statement };
  
  if decl.Tag === 'Comments' then
    emit_declaration_comments(decl);
  elsif decl.Tag === 'Function' then
    emit_declaration_function(decl);
  elsif decl.Tag === 'Variable' then
    emit_declaration_variable(decl);
  elsif decl.Tag === 'Variables' then
    emit_declaration_variables(decl);
  elsif decl.Tag === 'Statement' then
    emit_statement(decl.Statement);
  else
    die(`unknown Declaration.Tag: ${decl.Tag} in ${describe(decl, 2000)}`);
  end
end

fn emit_declaration_comments(decl) do
  // decl is { Tag: 'Comments', Comments: [token...] }
  
  for var c of decl.Comments do
    emit(c.Text);
    if c.Type === 'EOL_COMMENT' then
      nl_and_indent();
    end
  end
end

fn emit_declaration_function(decl) do
  // decl is { Tag: 'Function'
  //         , Name: string
  //         , Signature: FunctionSignature
  //         , Body: Statement/List
  //         , Exported: boolean
  //         , IsAsync: boolean
  //         }
  // FunctionSignature is { Kind: 'FunctionSignature', DelimiterLeft, DelimiterRight, FormalParameters };
  // FormalParameters is  { Kind: 'List', Tag: 'Identifiers', Identifiers: [token...], Commas: [token...] }
  
  emit(decl.Exported ? 'export ' : '');
  emit(decl.IsAsync ? 'async ' : '');
  emit(lang.func + ' ');
  emit(decl.Name);
  emit_list_of_names('(', decl.Signature.FormalParameters, ') ');
  emit_statement_block(decl.Body);
end

fn emit_declaration_variable(decl) do
  // decl is           { Tag: 'Variable', Keyword: Token, Variable, Initializer, Exported }
  
  emit(`${decl.Exported ? 'export ' : ''}${decl.Keyword.Text} ${decl.Variable}`);
  if isJust(decl.Initializer) then
    emit(' = ');
    emit_expression(decl.Initializer.Just);
  end
  emit(';');
end

fn emit_declaration_variables(decl) do
  // decl        is   { Tag: 'Variables', Keyword: Token, Variables, Initializer, Exported };
  // Keyword     is   'var', 'let', or 'const'
  // Variables   is   { Kind: 'List', Tag: 'Identifiers', Identifiers: [token...], Commas: [token...] }
  // Initializer is   Expression
  // Exported    is   boolean
  
  emit(`${decl.Exported ? 'export ' : ''}${decl.Keyword.Text} `);
  emit_list_of_names('[', decl.Variables, ']');
  emit(' = ');
  emit_expression(decl.Initializer);
  emit(';');
end

fn emit_statement(stmt) do
  // stmt is { Kind: 'Statement', Tag: 'If', If, Then, End, Test, Body, Else };
  //      or { Kind: 'Statement', Tag: 'While', While, Test, Body };
  //      or { Kind: 'Statement', Tag: 'For', For: Token, VarKeyword, Vars, Collection, Body, VarsBracketed };
  //      or { Kind: 'Statement', Tag: 'Throw', Throw: Token, Expression };
  //      or { Kind: 'Statement', Tag: 'Return', Return: Token, Expression };
  //      or { Kind: 'Statement', Tag: 'Expression', Expression };
  //      or { Kind: 'Statement', Tag: 'List', Statements };
  //      or { Kind: 'Statement', Tag: 'Block', Statements, Opener: Token, Closer: Token };
  
  if stmt.Tag === 'If' then
    lang.emit_if_stmt(stmt);
  elsif stmt.Tag === 'While' then
    emit_statement_while(stmt);
  elsif stmt.Tag === 'For' then
    emit_statement_for(stmt);
  elsif stmt.Tag === 'Throw' then
    emit_statement_throw(stmt);
  elsif stmt.Tag === 'Return' then
    emit_statement_return(stmt);
  elsif stmt.Tag === 'Expression' then
    emit_statement_expression(stmt);
  elsif stmt.Tag === 'List' || stmt.Tag === 'Block' then
    emit_statement_block(stmt);
  else
    nyi(`emit_statement of ${stmt.Kind}/${stmt.Tag}`);
  end
end

fn emit_statement_block(body) do
  // body is { Kind: 'Statement', Tag: 'List', Statements: [Declaration...] }
  // or      { Kind: 'Statement', Tag: 'List', Statements: [Declaration...], Opener: Token, Closer: Token }
  
  emit(lang.begin_block);
  emit_statement_list(body.Statements);
  nl_emit(lang.end_block);
end

fn emit_statement_list(stmt_list) do
  indent('  ');
  for let decl of stmt_list do
    nl_and_indent();
    emit_declaration(decl);
  end
  undent();
end

fn js_emit_statement_if(stmt) do
  // stmt is { Kind: 'Statement', Tag: 'If', If, Then, End, Test: Expression, Body, Else: Maybe(Statement) };
  // If   is a Token
  // Then is a Just(Token) if Spectra, None(Token) if SJS
  // End  is a Just(Token) if Spectra, None(Token) if SJS
  // Body is { Kind: 'Statement', Tag: 'List', Statements }
  //      or { Kind: 'Statement', Tag: 'Block', Statements, Opener, Closer }
  // Else is { Kind: 'Statement', Tab: 'List', Statements }
  //      or { Kind: 'Statement', Tag: 'Block', Statements, Opener, Closer }
  //      or { Kind: 'Statement', Tag: 'If', Test: Expression, Body, Else: Maybe(Statement) }
  
  emit('if (');
  emit_expression(stmt.Test);
  emit(') ');
  emit_statement_block(stmt.Body);
  if isJust(stmt.Else) then
    emit(" else ");
    emit_statement(stmt.Else.Just);
  end
end

fn sp1_emit_statement_if(stmt) do
  emit('if ');
  emit_expression(stmt.Test);
  emit(' then');
  emit_statement_list(stmt.Body.Statements);
  stmt = stmt.Else;
  while isJust(stmt) do
    stmt = stmt.Just;
    if stmt.Kind === 'Statement' && stmt.Tag === 'If' then
      nl_emit('elsif ');
      emit_expression(stmt.Test);
      emit(' then');
      emit_statement_list(stmt.Body.Statements);
      stmt = stmt.Else;
    elsif stmt.Kind === 'Statement' && (stmt.Tag === 'List' || 'Block') then
      nl_emit('else');
      emit_statement_list(stmt.Statements);
      nl_emit('end');
      return;
    end
  end
  nl_emit('end');
end

fn emit_statement_while(stmt) do
  // stmt is { Kind: 'Statement', Tag: 'While', While: Token, Test, Body };
  
  emit(`while ${lang.test_lpar}`);
  emit_expression(stmt.Test);
  emit(`${lang.test_rpar} `);
  emit_statement_block(stmt.Body);
end

fn emit_statement_for(stmt) do
  // stmt       is { Kind: 'Statement', Tag: 'For', For, VarKeyword, Vars, Collection, Body, VarsBracketed };
  // For        is Token
  // VarKeyword is Maybe(Token); if isJust(VarKeyword), VarKeyword.Text is one of {'var', 'let', 'const'}
  // Vars       is { Kind: 'List', Tag: 'Identifiers', Identifiers: [token...], Commas: [token...] }
  // Collection is Expression
  // Body       is Statement/List
  
  emit(`for ${lang.test_lpar}`);
  if isJust(stmt.VarKeyword) then
    emit(stmt.VarKeyword.Just.Text + ' ');
  end
  let [l, r] = stmt.VarsBracketed ? [
    '[',
    ']'
  ] : [
    '',
    ''
  ];
  emit_list_of_names(l, stmt.Vars, r);
  emit(' of ');
  emit_expression(stmt.Collection);
  emit(`${lang.test_rpar} `);
  emit_statement_block(stmt.Body);
end

fn emit_statement_throw(stmt) do
  // stmt      is { Kind: 'Statement', Tag: 'Throw', Throw: Token, Expression };
  // Exception is Expression
  
  emit('throw ');
  emit_expression(stmt.Expression);
  emit(';');
end

fn emit_statement_return(stmt) do
  // stmt is { Kind: 'Statement', Tag: 'Return', Return: Token, Expression: Maybe(Expression) };
  
  emit('return');
  if isJust(stmt.Expression) then
    emit(' ');
    emit_expression(stmt.Expression.Just);
  end
  emit(';');
end

fn emit_statement_expression(stmt) do
  emit_expression(stmt.Expression);
  emit(';');
end

fn emit_expression(expr) do
  // expr is            { Kind: 'Expression', Tag: 'Symbol', Name };
  //      or            { Kind: 'Expression', Tag: 'Literal', Literal };
  //      or            { Kind: 'Expression', Tag: 'Grouping', Expr };
  //      or            { Kind: 'Expression', Tag: 'Unary', Prefix: true, Operator, Operand };
  //      or            { Kind: 'Expression', Tag: 'Unary', Prefix: false, Operator, Operand };
  //      or            { Kind: 'Expression', Tag: 'Binary', Operator, Left, Right };
  //      or            { Kind: 'Expression', Tag: 'PostCircumfix', Left, Right, DelimiterLeft, DelimiterRight };
  //      or            { Kind: 'Expression', Tag: 'Ternary', Left, OperatorLeft, Middle, OperatorRight, Right };
  //      or            { Kind: 'Expression', Tag: 'New', FunctorName, Arguments: Expression_List };
  //      or            { Kind: 'Expression', Tag: 'Pair', Key, Value };
  //      or            { Kind: 'Expression', Tag: 'Object', DelimiterLeft, DelimiterRight, Pairs };
  //      or            { Kind: 'Expression', Tag: 'List', Expressions };
  //      or            { Kind: 'Expression', Tag: 'Array', Expressions };
  
  if expr.Tag === 'Symbol' then
    emit(expr.Name);
  elsif expr.Tag === 'Literal' then
    emit_expression_literal(expr.Literal);
  elsif expr.Tag === 'Grouping' then
    emit_expression(expr.Expr);
  elsif expr.Tag === 'Unary' then
    emit_expression_unary(expr);
  elsif expr.Tag === 'Binary' then
    emit_expression_binary(expr);
  elsif expr.Tag === 'PostCircumfix' then
    emit_expression_postcircumfix(expr);
  elsif expr.Tag === 'Ternary' then
    emit_expression_ternary(expr);
  elsif expr.Tag === 'Object' then
    emit_expression_object(expr);
  elsif expr.Tag === 'List' then
    emit_list_of_expressions('(', expr.Expressions, ')');
  elsif expr.Tag === 'Array' then
    emit_expression_array(expr);
  else
    throw new InternalError(`not yet implemented: emit_expression of ${expr.Kind}/${expr.Tag}`);
  end
end

fn emit_expression_literal(literal) do
  // literal is { Kind: 'Literal', Tag: 'Boolean', Value, Text };
  //         or { Kind: 'Literal', Tag: 'Fixnum', Value, Text };
  //         or { Kind: 'Literal', Tag: 'Flonum', Value, Text };
  //         or { Kind: 'Literal', Tag: 'String', Value, Text };
  //         or { Kind: 'Literal', Tag: 'Regexp', Value, Text };
  //         or { Kind: 'Literal', Tag: 'Function', Name, Signature, Body };
  //         or { Kind: 'Literal', Tag: 'ArrowFunctionExpression', Arrow: Token, Formals, Expr };
  //         or { Kind: 'Literal', Tag: 'ArrowFunctionBlock', Arrow: Token, Formals, Block };
  // Formals is { Kind: 'Expression', Tag: 'List', Expressions: [Expression...] }
  // Expr    is Expression
  // Block   is Statement/List
  
  let tag = literal.Tag;
  if tag === 'Regexp' then
    emit(literal.Text);
  elsif tag === 'Boolean' || tag === 'Fixnum' || tag === 'Flonum' || tag === 'String' || tag === 'Regexp' then
    emit(literal.Text);
  elsif tag === 'Function' then
    emit_literal_function(literal);
  elsif tag == 'ArrowFunctionExpression' then
    emit_expression_list('(', literal.Formals, ')');
    emit(' => ');
    emit_expression(literal.Expr);
  elsif tag === 'ArrowFunctionBlock' then
    emit_expression_list('(', literal.Formals, ')');
    emit(' => ');
    emit_statement_block(literal.Block);
  else
    nyi(`Expression/Literal with tag="${tag}"`);
  end
end

fn emit_expression_parenthesized(expr, useParentheses) do
  emit(useParentheses ? '(' : '');
  emit_expression(expr);
  emit(useParentheses ? ')' : '');
end

fn emit_expression_unary(expr) do
  // expr is { Kind: 'Expression', Tag: 'Unary', Prefix: true, Operator: string, Operand: Expression };
  
  let prec = precedence(expr);
  let op = expr.Operator.Text;
  if expr.Prefix then
    emit(op);
    if op === 'typeof' || op === 'await' || op === 'new' then
      emit(' ');
    end
  end
  emit_expression_parenthesized(expr.Operand, precedence(expr.Operand) < prec);
  if !expr.Prefix then
    emit(op);
  end
end

fn emit_expression_binary(expr) do
  // expr is { Kind: 'Expression', Tag: 'Binary', Operator: string, Left: Expression, Right: Expression };
  
  let op = expr.Operator.Text;
  if op === 'new' then
    emit('new ');
    emit_expression(expr.Left);
    emit_expression(expr.Right);
    return;
  elsif op === '[' then
    emit_expression_parenthesized(expr.Left, precedence(expr.Left) < precedence(expr));
    emit_list_of_expressions('[', [ expr.Right ], ']');
    return;
  end
  let prec = precedence(expr);
  emit_expression_parenthesized(expr.Left, precedence(expr.Left) < prec);
  if prec >= 17 then
    emit(op);
  else
    emit(` ${op} `);
  end
  emit_expression_parenthesized(expr.Right, precedence(expr.Right) < prec);
end

fn emit_expression_postcircumfix(expr) do
  // expr is { Kind: 'Expression', Tag: 'PostCircumfix', DelimiterLeft: Token, DelimiterRight: Token,
  //                                                     Left: Expression, Right: Expression };
  
  let op1 = expr.DelimiterLeft.Text;
  let op2 = expr.DelimiterRight.Text;
  if op1 === '[' then
    // 'Index', i.e., array subscript
    
    emit_expression_parenthesized(expr.Left, precedence(expr.Left) < precedence(expr));
    emit_list_of_expressions(op1, [ expr.Right ], op2);
  elsif op1 === '(' then
    // 'Apply', i.e. function application
    
    emit_expression_parenthesized(expr.Left, precedence(expr.Left) < precedence(expr));
    emit_expression_list('(', expr.Right, ')');
  end
end

fn emit_expression_ternary(expr) do
  // expr is { Kind: 'Expression', Tag: 'Ternary', Left, OperatorLeft: Token, Middle, OperatorRight: Token, Right };
  
  let prec = precedence(expr);
  emit_expression_parenthesized(expr.Left, precedence(expr.Left) <= prec);
  emit(' ? ');
  emit_expression_parenthesized(expr.Middle, precedence(expr.Middle) < prec);
  emit(' : ');
  emit_expression_parenthesized(expr.Right, precedence(expr.Right) < prec);
end

fn emit_expression_object(expr) do
  // expr  is { Kind: 'Expression', Tag: 'Object', DelimiterLeft: Token, DelimiterRight: Token, Pairs };
  // Pairs is [Pair...]
  
  if expr.Pairs.length === 0 then
    emit('{  }');
  elsif expr.Pairs.length === 1 then
    emit('{ ');
    emit_pair(expr.Pairs[0]);
    emit(' }');
  else
    indent('  ');
    let comma = '{';
    for let p of expr.Pairs do
      emit(comma);
      nl_emit('');
      emit_pair(p);
      comma = ',';
    end
    undent();
    nl_emit('}');
  end
end

fn emit_expression_array(expr) do
  // expr is  { Kind: 'Expression', Tag: 'Array', Expressions };
  // Expressions is { Kind: 'Expression', Tag: 'List', Expressions: [Expression...] }
  
  let exprs = expr.Expressions.Expressions;
  if exprs.length === 0 then
    emit('[ ]');
  elsif exprs.length === 1 then
    emit('[ ');
    emit_expression(exprs[0]);
    emit(' ]');
  else
    indent('  ');
    let comma = '[';
    for let p of exprs do
      emit(comma);
      nl_emit('');
      emit_expression(p);
      comma = ',';
    end
    undent();
    nl_emit(']');
  end
end

fn emit_key(expr) do
  if expr.Tag === 'Symbol' && lang.is_keyword(expr.Name) then
    emit(`'${expr.Name}'`);
  else
    emit_expression(expr);
  end
end

fn emit_pair(pair) do
  // pair is { Kind: 'Expression', Tag: 'Pair', Operator: Token(":"), Key, Value: Expression };
  // key  is { Kind: 'Expression', Tag: 'Symbol', Name }
  //      or { Kind: 'Expression', Tag: 'Literal', Literal: Literal/String }
  // Literal/String is { Kind: 'Literal', Tag:  'String', Value: string, Text: string };
  
  emit_key(pair.Key);
  if isJust(pair.Value) then
    emit(': ');
    emit_expression(pair.Value.Just);
  end
end

fn emit_expression_list(prefix, expression_list, postfix) do
  emit_list_of_expressions(prefix, expression_list.Expressions, postfix);
end

fn emit_list_of_expressions(prefix, exprs, postfix) do
  emit(prefix);
  let comma = '';
  for let x of exprs do
    emit(comma);
    emit_expression(x);
    comma = ', ';
  end
  emit(postfix);
end

fn emit_list_of_names(prefix, list_identifiers, postfix) do
  // list_identifiers is { Kind: 'List', Tag: 'Identifiers', Identifiers: [token...], Commas: [token...] }
  
  emit(prefix);
  let comma = '';
  for let x of list_identifiers.Identifiers do
    emit(comma);
    emit(x.Text);
    comma = ', ';
  end
  emit(postfix);
end

fn emit_literal_function(func) do
  // func              is { Kind: 'Literal', Tag: 'Function', Fn: Token, Name: string, Signature, Body };
  // Signature         is FunctionSignature
  // Body              is Statement/List
  // FunctionSignature is { Kind: 'FunctionSignature', Tag: 'FunctionSignature', DelimiterLeft, DelimiterRight,
  //                        FormalParameters };
  // FormalParameters is  { Kind: 'List', Tag: 'Identifiers', Identifiers: [token...], Commas: [token...] }
  
  emit(lang.func + ' ');
  if func.Name.Text !== '' then
    emit(func.Name.Text);
  end
  emit_list_of_names('(', func.Signature.FormalParameters, ')');
  emit_statement_block(func.Body);
end

fn precedence(expr) do
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence
  //console.log(`calculating precedence of ${describe(expr)}`);
  
  if expr.Tag === 'Grouping' then
    return precedence(expr.Expr);
  elsif expr.Tag === 'Unary' then
    let op = expr.Operator.Text;
    if expr.Prefix then
      if op === '-' || op === '+' || op === '!' || op === '++' || op === '--' || op === 'typeof' || op === 'await' || op === 'new' then
        return 14;
      end
    elsif op === '--' || op === '++' then
      return 15;
    elsif op === 'new' then
      return 16;
    end
  elsif expr.Tag === 'Binary' then
    let op = expr.Operator.Text;
    if op === ',' then
      return 1;
    elsif op === '=' || op === '+=' || op === '-=' || op === '*=' || op === '/=' then
      return 2;
    elsif op === '||' then
      return 3;
    elsif op === '&&' then
      return 4;
    elsif op === '==' || op === '===' || op === '!=' || op === '!==' then
      return 8;
    elsif op === '<' || op === '>' || op === '<=' || op === '>=' || op === 'in' then
      return 9;
    elsif op === '-' || op === '+' then
      return 11;
    elsif op === '*' || op === '/' || op === '%' then
      return 12;
    elsif op === '**' then
      return 13;
    elsif op === '.' || op === 'new' then
      return 17;
    end
  elsif expr.Tag === 'PostCircumfix' then
    let op = expr.DelimiterLeft.Text;
    if op === '[' || op === '(' then
      return 17;
    end
  elsif expr.Tag === 'Ternary' then
    return 2;
  elsif expr.Tag === 'Symbol' || expr.Tag === 'Literal' || expr.Tag === 'Grouping' then
    return 18;
  elsif expr.Tag === 'Object' || expr.Tag === 'Array' then
    return 18;
  elsif expr.Tag === 'Pair' then
    return 2;
    // this is really the comma operator inside object constructors
    
  elsif expr.Tag === 'New' then
    return 17;
  end
  throw new InternalError(`not yet implemented: precedence of ${to_s(expr)}`);
end
