// module main;
import { globSync} from 'glob';
import { spawn} from 'child_process';
import { describe} from '../src/sjs-parser.mjs';
import * as fs from 'fs';


const TestDirectory = "./test/resources";

const TestFiles = TestDirectory + "/*.{sjs,mjs,js,sp1}";

const IgnoreFiles = { ignore: { ignored: (p) => /\.compiled\./.test(p.name) } };

//function read_directory(input_file_name) {
//  fs.readdir(directoryPath, (err, files) => {
//    if (err) {
//      console.error('Error reading directory:', err);
//      return;
//    }
//    console.log('Contents of the directory:');
//    files.forEach(file => {
//      console.log(file);
//    });
//  });
//}


fn read_filenames_using_glob() do
  // glob docs: https://www.npmjs.com/package/glob
  //try {

  const files = globSync(TestFiles, IgnoreFiles);
  //console.log('Matching files:');
  //for (let file of files) {
  //  console.log(`${file} (${typeof file})`);
  //};

  return files;
  //} catch (err) {
  //  console.error(`Error reading test filenames:`, err);
  //  throw err;
  //}

end

fn slurp(filename) do
  return fs.readFileSync(filename, 'utf8');
end

fn run_program(program, argv) do
  const child = spawn(program, argv);
  let stdout = '';
  let stderr = '';
  child.stdout.on('data', (data) => do
    //console.log(`stdout|> ${data}`);

    stdout += data;
  end);
  child.stderr.on('data', (data) => do
    //console.error(`stderr|> ${data}`);

    stderr += data;
  end);
  return new Promise((resolve, reject) => do
    child.on('exit', (code) => do
      if code !== 0 then
        reject(new Error(`'${program} ${argv}' failed with exit code ${code}`));
      else
        resolve({
          status: code,
          stdout,
          stderr
        });
      end
    end);
  end);
end

async fn run_test(script_filename) do
  console.log(script_filename);
  let extension = new RegExp('[.][^.]*$|$');
  let output_filename = script_filename.replace(extension, '.compiled.mjs');
  // compile

  let result = await run_program('node', [
    'src/prism.mjs',
    script_filename
  ]);
  if result.status !== 0 then
    console.error(`  Failed to compile ${script_filename}`);
    return false;
  end
  //console.log(`Result of compiling ${script_filename}: ${describe(result, 2000)}`);
  // run

  result = await run_program('node', [ output_filename ]);
  if result.status !== 0 then
    console.error(`  Failed to run ${output_filename}`);
    return false;
  end
  if result.stderr !== '' then
    console.error(`  Unexpected text on stdout:\n ${result.stderr.replace(/^/gm, '    ')}`);
    return false;
  end
  //console.log(`Result of running ${output_filename}: ${describe(result, 2000)}`);

  let source = await slurp(script_filename);
  //console.log(`source:\n${source}`);

  let m = source.match(/^\s*\/\/\s*OUTPUT:\s*$.(?<output>.*)/ms);
  if !m then
    console.error(`  Could not find \`// OUTPUT: ...\` in ${script_filename}`);
    return false;
  end
  //console.log(`Expected output:\n${m.groups.output}`);
  // Trim leading and trailing whitespace from `expected` (including leading `//`)

  let expected = m.groups.output.replace(/^\s*\/\/\s*|\s+$/gm, '');
  //console.log(`Expected output (cleaned):\n${expected}`);
  // Trim leading and trailing whitespace from `received`

  let received = result.stdout.replace(/^\s+|\s+$/gm, '');
  if received !== expected then
    expected = expected.replace(/^/gm, '    ');
    received = received.replace(/^/gm, '    ');
    let RED = "\x1b[1;31m";
    // actually, bold red

    let RESET = "\x1b[0m";
    console.error(`  Test failed.\n  Expected:\n${expected}\n  Received:\n${RED}${received}${RESET}`);
    return false;
  end
  return true;
end

// When run as
//     node THIS_SCRIPT ARG1 ARG2
// we get
//     process.argv[0] == 'node'
//     process.argv[1] == 'THIS_SCRIPT'
//     process.argv[2] == 'ARG1'
//     process.argv[3] == 'ARG2'


async fn main() do
  const filenames = read_filenames_using_glob();
  let ok = true;
  filenames.sort();
  for let filename of filenames do
    let file_ok = await run_test(filename);
    let deliberate_failure_test_name = /test-00[.]/i;
    let should_fail = deliberate_failure_test_name.test(filename);
    if file_ok === should_fail then
      ok = false;
    end
  end
  return ok ? 0 : 1;
end

let status = await main();

process.exit(status);
